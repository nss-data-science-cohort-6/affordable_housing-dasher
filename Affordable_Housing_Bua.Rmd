---
title: "Assessing the Impact of Affordable Housing Development"
output: html_notebook
---


```{r}
library(readr)
library(readxl)
library(tidyverse)
```

```{r}
filtered_sales <- read_csv("filtered_sales.csv") 
assessments <- read_csv("assessments.csv")
LIHTC <- read_csv("LIHTC.csv")
property_details <- read_csv("property_details.csv")
barnes <- read_csv("barnes.csv")
X2021_Active_Property_List <- read_excel("2021_Active_Property_List.xlsx")

#filtered_sales, assessments, property_details can join on 'apn'
```

```{r}
#Data Manipulations in filtered_sales
filtered_sales$owneryear <- format(filtered_sales$ownerdate, format = "%Y")
filtered_sales$ownermonth <- format(filtered_sales$ownerdate, format = "%m")

assessments$effective_year <- format(assessments$effectivedate, format = "%Y")
assessments$effective_month <- format(assessments$effectivedate, format = "%m")

#Check duplicated rows 
nrow(filtered_sales[duplicated(filtered_sales),]) #7507
nrow(assessments[duplicated(assessments),]) #23160
nrow(property_details[duplicated(property_details),]) #2

#General Exploratory Analysis
length(unique(filtered_sales$apn)) #38.62762% of the data set are unique apn in filtered_sales

```

```{r}
#filtered_sales contains sales of single family homes from 1995 to the present day. It has been filtered to remove sales that are likely not arms-length transactions and transactions for parcels which did not have a house on them at the time of sale. This was done by removing any transations for $0, any transactions for which the adjacent appraisal values showed $0 for improvents, and any for which the transaction amount was less than half of the adjacent appraisals. 

filtered_sales %>%
  distinct() %>%
  group_by(owneryear) %>%
  summarize(sum_amount = sum(amount)) %>%
  ggplot(aes(x=owneryear, y=sum_amount))+
  geom_col()+
  ggtitle('Total Sales by Owner Year')+
  theme(axis.text.x = element_text(angle = 45, hjust=1))+
  xlab('Owner Year')+
  scale_y_continuous(name = 'Total Amount in USD (billions)', labels = unit_format(scale = 1e-9, unit = ''))

filtered_sales %>%
  distinct() %>%
  group_by(owneryear) %>%
  summarize(max_amount = max(amount)) %>%
  ggplot(aes(x=owneryear, y=max_amount))+
  geom_col(fill='red')+
  ggtitle('Max Sales by Owner Year')+
  theme(axis.text.x = element_text(angle = 45, hjust=1))+
  xlab('Owner Year')+
  scale_y_continuous(name = 'Max Sales USD (millions)', labels = unit_format(scale = 1e-6, unit = ''))

filtered_sales %>%
  distinct() %>%
  group_by(owneryear) %>%
  summarize(median_amount = median(amount)) %>%
  ggplot(aes(x=owneryear, y=median_amount))+
  geom_col(fill='blue')+
  ggtitle('Median Sales by Owner Year')+
  theme(axis.text.x = element_text(angle = 45, hjust=1))+
  xlab('Owner Year')+
  scale_y_continuous(name = 'Median Sales USD (millions)', labels = unit_format(scale = 1e-5, unit = ''))

filtered_sales %>%
  distinct() %>%
  group_by(owneryear) %>%
  summarize(count_apn = n_distinct(apn)) %>%
  ggplot(aes(x=owneryear, y=count_apn))+
  geom_col(fill='pink')+
  ggtitle('Historical Unique Property Count by Owner Year')+
  theme(axis.text.x = element_text(angle = 45, hjust=1))+
  xlab('Owner Year')+
  scale_y_continuous(name = 'Count of Unique Property (in 1000s)', labels = unit_format(scale = 1e-3, unit = ''))


```



```{r}
# 1. Using the sf library, find the closest development to each home. Hint: You can convert a tibble to an sf (simple feature) object using the [`st_as_sf` function](https://r-spatial.github.io/sf/reference/st_as_sf.html). See, for example, this stackoverflow post: https://gis.stackexchange.com/questions/222978/lon-lat-to-simple-features-sfg-and-sfc-in-r. Once converted, you can use the [`get_nearest_feature` function](https://r-spatial.github.io/sf/reference/st_nearest_feature.html).

library(stringr)
property_details[c('Longitude', 'Latitude')] <- str_split_fixed(property_details$centroid, ',', 2)
property_details$Longitude <- str_sub(property_details$Longitude, 2, -1)
property_details$Latitude <- str_sub(property_details$Latitude, 1, -2)

library(sf)

#Generate 'geometry' column in LIHTC and property_details
LIHTC <- st_as_sf(LIHTC, coords = c("LONGITUDE", "LATITUDE"), 
                 crs = 4326, agr = "constant")

property_details <- st_as_sf(property_details, coords = c("Longitude", "Latitude"), 
                 crs = 4326, agr = "constant")

#The following code returns: for each feature (geometry) in property_details the index of the nearest feature (geometry) in set LIHTC
try(st_nearest_feature(property_details, LIHTC))

#Add HUD_ID column to property_details
property_details$HUD_ID <- LIHTC$HUD_ID[st_nearest_feature(property_details, LIHTC)]

```


```{r}
#2. Calculate the distance from each home its closest development.
# test prop_distance <- st_distance(property_details[1:10,], LIHTC)

#Rohit code from Slack
nearest_development <- LIHTC[st_nearest_feature(property_details, LIHTC), ]
property_details$NNDist <- as.numeric(st_distance(property_details, nearest_development, by_element = T))

library(maps)
#subset of lat long around Davidson County from map_data 
county.lines <- subset(map_data('county'),region=='tennessee' & subregion=='davidson') 

#NNDist: nearest neighbor distance

ggplot(property_details)+
  geom_sf(aes(colour=NNDist))+
  geom_sf(data = LIHTC, shape=23) +
  geom_path(data = county.lines, mapping=aes(x=long, y=lat, group=group)) +
  scale_colour_gradientn(colours=rainbow(100)[75:1]) 
  
# group=group name of a column in county.lines
# affordable housing developments (diamiond shapes) are right on the purple color
# ?pch
#this splits the rainbow into 100 colours, we only want 75 of the 100 rainbow colours but in reverse order [75:1]

#distances are small in the center 
```

```{r}
#Create an interactive map using leaflet

library(leaflet)

#Read in shapefile for Davidson County Boarder
boarder_shapefile <- st_read("Data/Davidson County Border (GIS)/geo_export_bb5b211c-8776-4c69-b6b8-a10ee043fd18.shp", as_tibble = T, quiet = T) %>%
  st_transform('+proj=longlat +datum=WGS84')

map <- leaflet(options = leafletOptions(minZoom = 10)) %>%
  addProviderTiles(provider = "CartoDB.Voyager") %>%
  setView(lng = -86.7816, lat = 36.1627, zoom = 12) %>%
  setMaxBounds(lng1 = -86.7816 + 1, 
               lat1 = 36.1627 + 1, 
               lng2 = -86.7816 - 1, 
               lat2 = 36.1627 - 1) %>%
  addCircleMarkers(data = LIHTC,
                   radius = 5,
                   color = "white",
                   weight = 1,
                   fillColor = "red",
                   fillOpacity = 0.75) %>%
  addMarkers(data = property_details,
                   # radius = 5,
                   # color = "white",
                   # weight = 1,
                   # fillColor = "blue",
                   # fillOpacity = 0.75,
                   clusterOptions = markerClusterOptions()) %>%
  addPolylines(data = boarder_shapefile)

map

```


```{r}
#3. Filter the homes down to those that are within one mile of an affordable housing development.
# 1 mile = 1609 m
property_within_1mile <- subset(property_details, NNDist<1609)

#69705 observations are within a mile of the nearest affordable housing developments
```


```{r}
#4. For each remaining home, calculate a new column called "group", which is defined according to the following rules. Hint: Use the `case_when` function to do this. 

#For this project, we'll be focusing on single family homes and look at affordable housing developments that were placed in service in 2000 or later.


property_details <- merge(property_details, unique(st_drop_geometry(LIHTC)[c("HUD_ID","YR_PIS")]), by = "HUD_ID", all.x=T)

property_details <- merge(property_details, unique(filtered_sales[c("apn","ownerdate")]), by = "apn", all.x=T)

property_details <- merge(property_details, unique(assessments[c("apn","class")]), by = "apn", all.x=T)

#unique(assessments[c("class","classdesc")])

#	* "pre" - for homes where the distance is less than half a mile and whose sale date was 2-5 years prior to the input year (YR_PIS in LIHTC) 

#	* "mid" - for homes where the distance is less than half a mile and whose sale date was 0-2 years prior to the input year  

#	* "post" - for homes where the distance is less than half a mile and whose sale date was after the input year  

#	* "outside" - for homes where the distance is more than half a mile and whose sale date was no more than 5 years prior to the input year  

#	* "other" - All other rows  

library(lubridate)
property_details = property_details %>%
  filter(YR_PIS>=2000 & class == "R" & !YR_PIS %in% c(8888,9999)) %>%
  mutate(group = case_when(
    NNDist < 804.5 & (YR_PIS - year(ownerdate)) %in% 2:5 ~ "pre",
    NNDist < 804.5 & (YR_PIS - year(ownerdate)) %in% 0:1 ~ "mid",
    NNDist < 804.5 & (YR_PIS - year(ownerdate)) < 0 ~ "post",
    NNDist > 804.5 & (YR_PIS - year(ownerdate)) <= 5 ~ "outside",
    TRUE ~ "other"
  ))

#check
sort(unique(property_details$YR_PIS))
unique(property_details$class)
property_details %>%
  group_by(group) %>%
  summarize(maxdist = max(NNDist), maxyear_diff=max(YR_PIS - year(ownerdate)), minyear_diff=min(YR_PIS - year(ownerdate)))

```

```{r}
#5. Filter out all rows whose group is "other".

property_details_filtered = property_details %>%
  filter(YR_PIS>=2000 & class == "R" & !YR_PIS %in% c(8888,9999)) %>%
  mutate(group = case_when(
    NNDist < 804.5 & (YR_PIS - year(ownerdate)) %in% 2:5 ~ "pre",
    NNDist < 804.5 & (YR_PIS - year(ownerdate)) %in% 0:1 ~ "mid",
    NNDist < 804.5 & (YR_PIS - year(ownerdate)) < 0 ~ "post",
    NNDist > 804.5 & (YR_PIS - year(ownerdate)) <= 5 ~ "outside",
    TRUE ~ "other"
  )) %>%
  filter(group != "other")
```

```{r}
#6. Add an id column containing the id value for the development. (HUD_ID from LIHTC?)
# Already did this in Q2 

```

```{r}
#7. Create a column "Tpost" that, for homes in the "post" group gives the number of years that the sale occurred after the housing development was placed in service.

property_details_filtered$Tpost <- 
  ifelse(property_details_filtered$group == "post", 
         year(property_details_filtered$ownerdate) - property_details_filtered$YR_PIS,
         NA)

#check
property_details_filtered %>%
  group_by(group) %>%
  summarize(meanTpost = mean(Tpost, na.rm=T), minTpost = min(Tpost, na.rm=T))

```
```{r}
#8. Create a column named "age" which gives the age of the home at the time of sale.
property_details_filtered$age <- as.numeric(year(property_details_filtered$ownerdate) - year_built)
```

```{r}
#9. Filter down to only sales that took place within the five years before or after the associated development was placed in service. Then build a linear model with target variable the sales amount using the following features:
	- square_footage
	- age of home at time of sale
	- group
	- year
	- tract
How can you interpret the coefficients of this model?
  
#10. Now, try a model with target being the log of the sale price.
	- square_footage
	- age of home at time of sale
	- group
	- year
	- tract
How can you interpret the coefficients of this model?
  
#11. Continue to explore the data to see if you can improve the models you have.
```




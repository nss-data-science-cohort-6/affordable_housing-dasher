---
title: "Assessing the Impact of Affordable Housing Development"
output: html_notebook

---


```{r}
library(readr)
library(readxl)
library(tidyverse)
library(flexdashboard)
```

```{r}
filtered_sales <- read_csv("filtered_sales.csv") 
assessments <- read_csv("assessments.csv")
LIHTC <- read_csv("LIHTC.csv")
LIHTC_filtered <- subset(LIHTC, YR_PIS >= 2000 & !YR_PIS %in% c(8888,9999))

property_details <- read_csv("property_details.csv")

barnes <- read_csv("barnes.csv")
barnes$HUD_ID <- c('TNA081023A00400CO',
	        'TNA09211010400',
            'TNA081023A90000CO',
            'TNA08600035500',
            'TNA10613000800',
            'TNA05108017800',
            'TNA09311022700',
            'TNA06912006600',
            'TNA10601016800')
barnes = barnes %>% rename(YS_PIS = `Barnes Year`, 
                           PROJ_ADD = `Street Address`, 
                           PROJ_CTY = City, 
                           PROJ_ZIP = `Zip Code`) %>%
                    select(YS_PIS,PROJ_ADD,PROJ_CTY,PROJ_ZIP,geometry, HUD_ID)

LIHTC_filtered <- bind_rows(LIHTC_filtered, barnes)

```

```{r}
#Data Manipulations in filtered_sales
filtered_sales$owneryear <- format(filtered_sales$ownerdate, format = "%Y")
filtered_sales$ownermonth <- format(filtered_sales$ownerdate, format = "%m")

assessments$effective_year <- format(assessments$effectivedate, format = "%Y")
assessments$effective_month <- format(assessments$effectivedate, format = "%m")

#Check duplicated rows 
nrow(filtered_sales[duplicated(filtered_sales),]) #7507
nrow(assessments[duplicated(assessments),]) #23160
nrow(property_details[duplicated(property_details),]) #2

#General Exploratory Analysis
length(unique(filtered_sales$apn)) #38.62762% of the data set are unique apn in filtered_sales

```

```{r}
#filtered_sales contains sales of single family homes from 1995 to the present day. It has been filtered to remove sales that are likely not arms-length transactions and transactions for parcels which did not have a house on them at the time of sale. This was done by removing any transations for $0, any transactions for which the adjacent appraisal values showed $0 for improvents, and any for which the transaction amount was less than half of the adjacent appraisals. 

filtered_sales %>%
  distinct() %>%
  group_by(owneryear) %>%
  summarize(sum_amount = sum(amount)) %>%
  ggplot(aes(x=owneryear, y=sum_amount))+
  geom_col()+
  ggtitle('Total Sales by Owner Year')+
  theme(axis.text.x = element_text(angle = 45, hjust=1))+
  xlab('Owner Year')+
  scale_y_continuous(name = 'Total Amount in USD (billions)', labels = unit_format(scale = 1e-9, unit = ''))

filtered_sales %>%
  distinct() %>%
  group_by(owneryear) %>%
  summarize(max_amount = max(amount)) %>%
  ggplot(aes(x=owneryear, y=max_amount))+
  geom_col(fill='red')+
  ggtitle('Max Sales by Owner Year')+
  theme(axis.text.x = element_text(angle = 45, hjust=1))+
  xlab('Owner Year')+
  scale_y_continuous(name = 'Max Sales USD (millions)', labels = unit_format(scale = 1e-6, unit = ''))

filtered_sales %>%
  distinct() %>%
  group_by(owneryear) %>%
  summarize(median_amount = median(amount)) %>%
  ggplot(aes(x=owneryear, y=median_amount))+
  geom_col(fill='blue')+
  ggtitle('Median Sales by Owner Year')+
  theme(axis.text.x = element_text(angle = 45, hjust=1))+
  xlab('Owner Year')+
  scale_y_continuous(name = 'Median Sales USD (millions)', labels = unit_format(scale = 1e-5, unit = ''))

filtered_sales %>%
  distinct() %>%
  group_by(owneryear) %>%
  summarize(count_apn = n_distinct(apn)) %>%
  ggplot(aes(x=owneryear, y=count_apn))+
  geom_col(fill='pink')+
  ggtitle('Historical Unique Property Count by Owner Year')+
  theme(axis.text.x = element_text(angle = 45, hjust=1))+
  xlab('Owner Year')+
  scale_y_continuous(name = 'Count of Unique Property (in 1000s)', labels = unit_format(scale = 1e-3, unit = ''))


```

1. Using the sf library, find the closest development to each home. Hint: You can convert a tibble to an sf (simple feature) object using the [`st_as_sf` function](https://r-spatial.github.io/sf/reference/st_as_sf.html). See, for example, this stackoverflow post: https://gis.stackexchange.com/questions/222978/lon-lat-to-simple-features-sfg-and-sfc-in-r. Once converted, you can use the [`get_nearest_feature` function](https://r-spatial.github.io/sf/reference/st_nearest_feature.html).

```{r}
library(stringr)
property_details[c('Longitude', 'Latitude')] <- str_split_fixed(property_details$centroid, ',', 2)
property_details$Longitude <- str_sub(property_details$Longitude, 2, -1)
property_details$Latitude <- str_sub(property_details$Latitude, 1, -2)

library(sf)

#Generate 'geometry' column in LIHTC and property_details
LIHTC_filtered <- st_as_sf(LIHTC_filtered, coords = c("LONGITUDE", "LATITUDE"), 
                 crs = 4326, agr = "constant")

property_details <- st_as_sf(property_details, coords = c("Longitude", "Latitude"), 
                 crs = 4326, agr = "constant")


#Add HUD_ID column to property_details
property_details$HUD_ID <- LIHTC_filtered$HUD_ID[st_nearest_feature(property_details, LIHTC_filtered)]

```

2. Calculate the distance from each home its closest development. 

```{r}
#Rohit code from Slack
nearest_development <- LIHTC_filtered[st_nearest_feature(property_details, LIHTC_filtered), ]
property_details$NNDist <- as.numeric(st_distance(property_details, nearest_development, by_element = T))

library(maps)
#subset of lat long around Davidson County from map_data 
county.lines <- subset(map_data('county'),region=='tennessee' & subregion=='davidson') 

#NNDist: nearest neighbor distance

ggplot(property_details)+
  geom_sf(aes(colour=NNDist))+
  geom_sf(data = LIHTC_filtered, shape=23) +
  geom_path(data = county.lines, mapping=aes(x=long, y=lat, group=group)) +
  scale_colour_gradientn(colours=rainbow(100)[75:1]) 
  
# group=group name of a column in county.lines
# affordable housing developments (diamiond shapes) are right on the purple color
# ?pch
# this splits the rainbow into 100 colours, we only want 75 of the 100 rainbow colours but in reverse order [75:1]
# distances are small in the center 
```
Create an interactive map using leaflet

```{r}
library(leaflet)

#Read in shapefile for Davidson County Boarder
boarder_shapefile <- st_read("Data/Davidson County Border (GIS)/geo_export_bb5b211c-8776-4c69-b6b8-a10ee043fd18.shp", as_tibble = T, quiet = T) %>%
  st_transform('+proj=longlat +datum=WGS84')

map <- leaflet(options = leafletOptions(minZoom = 10)) %>%
  addProviderTiles(provider = "CartoDB.Voyager") %>%
  setView(lng = -86.7816, lat = 36.1627, zoom = 12) %>%
  setMaxBounds(lng1 = -86.7816 + 1, 
               lat1 = 36.1627 + 1, 
               lng2 = -86.7816 - 1, 
               lat2 = 36.1627 - 1) %>%
  addCircleMarkers(data = LIHTC_filtered,
                   radius = 5,
                   color = "white",
                   weight = 1,
                   fillColor = "red",
                   fillOpacity = 0.75) %>%
  addMarkers(data = property_details,
                   # radius = 5,
                   # color = "white",
                   # weight = 1,
                   # fillColor = "blue",
                   # fillOpacity = 0.75,
                   clusterOptions = markerClusterOptions()) %>%
  addPolylines(data = boarder_shapefile)

map

```

3. Filter the homes down to those that are within one mile of an affordable housing development. (1 mile = 1609 m)

```{r}
property_within_1mile <- subset(property_details, NNDist<1609)

#54760 observations are within a mile of the nearest affordable housing developments
```

4. For each remaining home, calculate a new column called "group", which is defined according to the following rules. Hint: Use the `case_when` function to do this. 

* "pre" - for homes where the distance is less than half a mile and whose sale date was 2-5 years prior to the input year (YR_PIS in LIHTC) 

* "mid" - for homes where the distance is less than half a mile and whose sale date was 0-2 years prior to the input year  

* "post" - for homes where the distance is less than half a mile and whose sale date was after the input year  

* "outside" - for homes where the distance is more than half a mile and whose sale date was no more than 5 years prior to the input year  

* "other" - All other rows 

For this project, we'll be focusing on single family homes and look at affordable housing developments that were placed in service in 2000 or later.

```{r}
property_details_merge <- merge(property_details, unique(st_drop_geometry(LIHTC_filtered)[c("HUD_ID","YR_PIS")]), by = "HUD_ID", all.x=T)

property_details_merge <- merge(property_details_merge, unique(filtered_sales[c("apn","ownerdate","amount")]), by = "apn", all.x=T)

library(lubridate)
property_details_merge = property_details_merge %>%
  #filter(YR_PIS>=2000 & class == "R" & !YR_PIS %in% c(8888,9999)) %>%
  mutate(group = case_when(
    NNDist < 804.5 & (YR_PIS - year(ownerdate)) %in% 2:5 ~ "pre",
    NNDist < 804.5 & (YR_PIS - year(ownerdate)) %in% 0:1 ~ "mid",
    NNDist < 804.5 & (YR_PIS - year(ownerdate)) < 0 ~ "post",
    NNDist > 804.5 & (YR_PIS - year(ownerdate)) <= 5 ~ "outside",
    TRUE ~ "other"
  ))

#check
sort(unique(property_details_merge$YR_PIS))

property_details_merge %>%
  group_by(group) %>%
  summarize(maxdist = max(NNDist), maxyear_diff=max(YR_PIS - year(ownerdate)), minyear_diff=min(YR_PIS - year(ownerdate)))

```


5. Filter out all rows whose group is "other".

```{r}
property_details_filtered = property_details_merge %>%
  mutate(group = case_when(
    NNDist < 804.5 & (YR_PIS - year(ownerdate)) %in% 2:5 ~ "pre",
    NNDist < 804.5 & (YR_PIS - year(ownerdate)) %in% 0:1 ~ "mid",
    NNDist < 804.5 & (YR_PIS - year(ownerdate)) < 0 ~ "post",
    NNDist > 804.5 & (YR_PIS - year(ownerdate)) <= 5 ~ "outside",
    TRUE ~ "other"
  )) %>%
  filter(group != "other")

#check
sort(unique(property_details_filtered$group))
```

6. Add an id column containing the id value for the development. (HUD_ID from LIHTC?)

```{r}

# Already did this in Q2 

```


7. Create a column "Tpost" that, for homes in the "post" group gives the number of years that the sale occurred after the housing development was placed in service.

```{r}
property_details_filtered$Tpost <- 
  ifelse(property_details_filtered$group == "post", 
         year(property_details_filtered$ownerdate) - property_details_filtered$YR_PIS,
         NA)

#check
property_details_filtered %>%
  group_by(group) %>%
  summarize(meanTpost = mean(Tpost, na.rm=T), minTpost = min(Tpost, na.rm=T), maxTpost = max(Tpost, na.rm=T))

```

8. Create a column named "age" which gives the age of the home at the time of sale.

```{r}
property_details_filtered$age <- as.numeric(year(property_details_filtered$ownerdate) - property_details_filtered$year_built)

#check
summary(property_details_filtered$age)
property_details_filtered %>%
  select(apn, year_built, ownerdate, age) %>%
  head(10)

# Negative age: How can a home be sold before it was built? Perhaps it was the property before the current house was built
```

9. Filter down to only sales that took place within the five years before or after the associated development was placed in service. 

Then build a linear model with target variable the sales amount using the following features: -->
- square_footage (num) -->
- age of home at time of sale (num) -->
- group (factor) -->
- year (num) -->
- tract (factor) -->
How can you interpret the coefficients of this model? -->

```{r}
property_details_filtered_within5yr <- property_details_filtered %>%
  subset(((YR_PIS - as.numeric(year(ownerdate))) %in% -5:5) & age > 0)

#check
summary(property_details_filtered_within5yr$YR_PIS - year(property_details_filtered_within5yr$ownerdate))

colnames(property_details_filtered_within5yr)

linear_model <- lm(amount ~ square_footage + age + year(ownerdate) + factor(group) + factor(tract), data = property_details_filtered_within5yr)
summary(linear_model)
```

10. Now, try a model with target being the log of the sale price.
 	- square_footage
 	- age of home at time of sale
 	- group
 	- year
 	- tract
 How can you interpret the coefficients of this model?

```{r}
log_linear_model <- lm(log(amount) ~ square_footage + age + year(ownerdate) + factor(group) + factor(tract), data = property_details_filtered_within5yr)
summary(log_linear_model)
```

```{r}
log_linear_model_notract <- lm(log(amount) ~ square_footage + age + year(ownerdate) + factor(group) , data = property_details_filtered_within5yr)
summary(log_linear_model_notract)
anova(log_linear_model_notract, log_linear_model) #we need tract
```

```{r}
log_linear_model_NNDist <- lm(log(amount) ~ square_footage + age + year(ownerdate) + factor(group) + factor(tract) + NNDist, data = property_details_filtered_within5yr)
summary(log_linear_model_NNDist)
anova(log_linear_model, log_linear_model_NNDist)
```

```{r}
log_linear_model_bdcnd <- lm(log(amount) ~ square_footage + age + year(ownerdate) + factor(group) + factor(tract) + factor(building_condition), data = property_details_filtered_within5yr)
summary(log_linear_model_bdcnd)
anova(log_linear_model, log_linear_model_bdcnd)
```


11. Continue to explore the data to see if you can improve the models you have.

add crime count per tract per year. data = Nashville Metro Police
add NNDist to model, maybe NNDist can replace tract
add crime variable (think about type of crimes) to dataset

Other variables to consider
unemployment rate, Housing Price Index, Interest Rates, Economic Indicators, Income, Population



